1、require、exports、module
2、require 多次导入同一个模块只会初始化一次
3、可以编写 二进制模块，扩展名为 .node 
4、模块加载规则：
	4.1 . ./ / ../ 开头的，按照相对和绝对路径加载
	4.2、若为 单个单词 的内置模块直接加载
	4.3、foo/bar 的路径，按照 运行 require的文件路径，从下向上查找 node_modules 文件夹下的 foo/bar 模块
	4.4、配置了 NODE_PATH 环境变量，搜索模块
	
5、npm install jquery -g --save-dev  => npm uninstall jquery -g --save-dev
6、npm login	npm publish		npm unpublish

7、process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径

8、fs.writeFileSync(dst, fs.readFileSync(src));
9、fs.createReadStream(src).pipe(fs.createWriteStream(dst));

10、var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
11、针对 Buffer 二进制数组的 slice 方法，返回的数组的修改会修改原 Buffer 数组（slice 更像是一个指针）
12、因此 slice 并不能复制数组，需要创建新的 Buffer ，使用 copy方法
	var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
	var dup = new Buffer(bin.length);

	bin.copy(dup);
	dup[0] = 0x48;
	console.log(bin); // => <Buffer 68 65 6c 6c 6f>
	console.log(dup); // => <Buffer 48 65 65 6c 6f>

13、文件管道流 pipe() 实现了防爆仓控制。
	其原理类似
	var rs = fs.createReadStream(src);
	var ws = fs.createWriteStream(dst);

	rs.on('data', function (chunk) {
	    if (ws.write(chunk) === false) {
	        rs.pause();
	    }
	});

	rs.on('end', function () {
	    ws.end();
	});

	ws.on('drain', function () {
	    rs.resume();
	});
14、fs 模块  基本上 异步 API 都有与之对应的同步API
	例如： readFile 和 readFileSync

	异步方法是回调，同步方法是 try catch 捕获错误
15、path 模块，内置，有方法  normalize 使路径正常化，返回字符串
	var path = require('path');
	var cache = {};

	function store(key, value) {
		cache[path.normalize(key).replace(/\\/g,'/')] = value;
	}
	store('foo/bar', 1);
	store('foo//bar//../bar', 2);
	console.log(cache);
16、路径拼接：
	path.join('foo/', 'baz/', '../bar'); // => "foo/bar"
17、获取pathname扩展名
	path.extname('asd.js/pasd.txt')